\documentclass{article}

\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{xcolor}

\newcommand{\defined}{\ensuremath{\stackrel{\mbox{\tiny def}}{=}}\xspace} %
\newcommand{\vars}{\ensuremath{\mathcal{X}}\xspace} % variables
\newcommand{\vals}{\ensuremath{\mathbb{V}}\xspace} % values
\newcommand{\bvals}{\ensuremath{\mathbb{B}_\mathsf{NA}}\xspace} % bool values
\newcommand{\bools}{\ensuremath{\mathbb{B}}\xspace} % bools
\newcommand{\bna}{\ensuremath{\mathsf{NA}_{B}}\xspace} % bool NA
\newcommand{\ivals}{\ensuremath{\mathbb{Z}_\mathsf{NA}}\xspace} % int values
\newcommand{\ints}{\ensuremath{\mathbb{Z}}\xspace} % ints
\newcommand{\ina}{\ensuremath{\mathsf{NA}_{Z}}\xspace} % int NA
\newcommand{\svals}{\ensuremath{\mathbb{S}_\mathsf{NA}}\xspace} % string values
\newcommand{\strings}{\ensuremath{\mathbb{S}}\xspace} % strings
\newcommand{\sna}{\ensuremath{\mathsf{NA}_{S}}\xspace} % string NA
\newcommand{\ipt}{\ensuremath{\mathsf{\mathbf{\color{teal}input}}()}\xspace} % input
\newcommand{\powerset}[1]{\ensuremath{\mathcal{P}\left(#1\right)}\xspace} % set
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace} % set
\newcommand{\tuple}[2]{\ensuremath{\langle #1, #2 \rangle}\xspace} % tuple
\newcommand{\lfp}{\ensuremath{\mathrm{lfp}}\xspace} % least fixpoint
%
\newcommand{\labels}{\ensuremath{\mathcal{L}}\xspace} % labels
\newcommand{\envs}{\ensuremath{\mathcal{E}}\xspace} % environments
\newcommand{\files}{\ensuremath{\mathcal{D}}\xspace} % files
\newcommand{\semantics}[1]{\ensuremath{\left\llbracket #1 \right\rrbracket}\xspace} % semantics
\newcommand{\arith}[1]{\ensuremath{\mathcal{A}\semantics{#1}}\xspace} % arithmetic semantics
\newcommand{\bool}[1]{\ensuremath{\mathcal{B}\semantics{#1}}\xspace} % boolean semantics
\newcommand{\stmt}[1]{\ensuremath{\mathcal{S}\semantics{#1}}\xspace} % statement semantics
% dependency semantics
\newcommand{\sdeps}[1]{\ensuremath{\textsc{s-deps}\!\semantics{#1}}\xspace} % static  
\newcommand{\ddeps}[1]{\ensuremath{\textsc{d-deps}\!\semantics{#1}}\xspace} % dynamic
\newcommand{\ids}[1]{\ensuremath{\textsc{vars}\!\semantics{#1}}\xspace} % 
\newcommand{\peek}[1]{\ensuremath{\textsc{peek}\!\semantics{#1}}\xspace} % 

\newcommand{\irem}[3]{{\noindent\textcolor{#1}{\textsf{[#2: 
#3]}}}}
\newcommand{\todo}[1]{\irem{orange}{TODO}{#1}}	
\newcommand{\note}[1]{\irem{magenta}{NOTE}{#1}}	

\begin{document}

\section*{Syntax}

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{lclr}
			A &$\Coloneqq$& $X$ & $X\in 
			\vars$ 
			\\
			&$\vert$& $v$ & $v \in \vals$ \\
			&$\vert$& $A_1 \diamond A_2 $ &
			\hspace{3em}$\diamond \in 
			\set{+,-,*,/}$ 
			\\
			\\
			B & $\Coloneqq$& $A_1 \bowtie A_2$ 
			&
			$\bowtie~\in
			\{<, \leq, =, \not=, >, \geq\}$ \\
			&$\vert$ & $%\neg B~~\vert~~
			B_1 \lor 
			B_2$ & \\
			&$\vert$& $B_1 
			\land B_2$ \\
			\\
			E &$\Coloneqq$& $\ipt~~\vert~~A~~\vert~~B$%~~\vert~~\mathsf{\mathbf{bool}}(E)~~\vert~~\mathsf{\mathbf{int}}(E)$ 
			& \\
			%&$\vert$& $\mathsf{\mathbf{bool}}(E)~~\vert~~\mathsf{\mathbf{int}}(E)$ \\
			\\
			S & $\Coloneqq$& $^\ell{}X := E$ & $\ell{} \in 
			\labels, X \in 
			\vars$ \\
			&$\vert$& 
			$\mathsf{\mathbf{if}}~^\ell{}X~\mathsf{\mathbf{then}}~S_1~\mathsf{\mathbf{else}}~S_2~\mathsf{\mathbf{fi}}$
			 & $\ell{} \in 
			 \labels$ \\
			 &$\vert$& 
			 $\mathsf{\mathbf{while}}~^\ell{}X~\mathsf{\mathbf{do}}~S~\mathsf{\mathbf{od}}$%~~\vert~~\mathsf{\mathbf{while}}~^lB~\mathsf{\mathbf{do}}~S~\mathsf{\mathbf{od}}$
			 & $\ell{} \in \labels$ 
			 \\
			 &$\vert$&  $S_1 ; S_2$ & \\
			 \\
			 P & $\Coloneqq$& $S^\ell{}$ & $\ell{} \in 
			 \labels$
		\end{tabular}
	\end{center}
	\vspace{-1em}
	\caption{Syntax}\label{fig:syntax}
\end{figure}

Let \vars be a finite set of program variables, and let $\vals\defined\bvals \cup \ivals \cup \svals$ be a set of values partitioned  in sets of boolean ($\bvals \defined \bools \cup \{\bna\} $), integer ($\ivals \defined \ints \cup \{\ina\} $), and string ($\svals \defined \strings \cup \{\sna\} $) values. Each value type admits a special value $\bna$, $\ina$, or $\sna$ representing missing values.
The syntax of programs is defined inductively in Figure~\ref{fig:syntax}.

\section*{Concrete Input-Aware Semantics}

An environment $\rho\colon \vars \rightarrow \vals$ maps each program variable $X \in \vars$ to its value $\rho(X) \in \vals$. Let \envs denote the set of all environments. 

\todo{Patrick Cousot - Abstract Semantic Dependency (SAS 2019)}


\section*{Syntactic Dependencies}

\subsection*{Static Syntactic Dependencies Analysis}

The program dependency semantics $\sdeps{P} \colon \powerset{\vars \times \labels}$ yields an \emph{over-approximation} of the input-output dependencies of the program $P$:
\begin{equation*}
\sdeps{S^\ell{}} \defined \sdeps{S}\emptyset
\end{equation*}
\note{we start the analysis with the empty set of dependencies}
where the statement dependency semantics $\sdeps{S} \colon \powerset{\vars \times \labels} \rightarrow  \powerset{\vars \times \labels}$ updates the input-output dependencies through the program:

%\begin{figure}[t]
	\begin{align*}
	&\sdeps{^\ell{}X := \ipt}R \defined R \setminus \{ \tuple{X}{\ell{}'} \mid \ell{}' \in \labels \} \cup \{ \tuple{X}{\ell{}} \} 
	%
	\\
	&\mbox{\note{\ipt expressions introduce new dependencies}} \\
	&\sdeps{^\ell{}X := E}R \defined R \setminus \{ \tuple{X}{\ell{}'} \mid \ell{}' \in \labels \} \cup \{ \tuple{X}{\ell{}'} \mid \exists X'\colon X' \in \ids{E} \land \tuple{X'}{\ell{}'} \in R \} \\
	&\qquad\mbox{where $E \not= \ipt$} \\
	&\mbox{\note{\ids{E} is the set of all program variables appearing in the expression $E$}} \\
%
	&\sdeps{\mathsf{\mathbf{if}}~^\ell{}X~\mathsf{\mathbf{then}}~S_1~\mathsf{\mathbf{else}}~S_2~\mathsf{\mathbf{fi}}}R
	 \defined \sdeps{S_1}R \cup \sdeps{S_2}R \\ 
%
&\sdeps{\mathsf{\mathbf{while}}~^\ell{}X~\mathsf{\mathbf{do}}~S~\mathsf{\mathbf{od}}}R
\defined \lfp~R \cup \sdeps{S}\emptyset  \\
&\todo{Is this ok? We keep all dependencies in R to account for executions that do not enter the loop.} \\
&\todo{We iterate to account for the loop executions. It may be equivalent to do $R \cup \sdeps{S}R$.} \\
%
&\sdeps{S_1; S_2}R \defined \sdeps{S_2} \circ 
\sdeps{S_1}R
	\end{align*}
%\end{figure}

\subsection*{Dynamic Syntactic Dependencies Analysis}

	\begin{align*}
	&\ddeps{^\ell{}X := \ipt}R \defined R \setminus \{ \tuple{X}{\ell{}'} \mid \ell{}' \in \labels \} \cup \{ \tuple{X}{\ell{}} \} 
	%
	\\
	&\ddeps{^\ell{}X := E}R \defined R \setminus \{ \tuple{X}{\ell{}'} \mid \ell{}' \in \labels \} \cup \{ \tuple{X}{\ell{}'} \mid \exists X'\colon X' \in \ids{E} \land \tuple{X'}{\ell{}'} \in R \} \\
	&\qquad\mbox{where $E \not= \ipt$} \\
	&\mbox{\note{same as \sdeps{S} so far}} \\
%
	&\ddeps{\mathsf{\mathbf{if}}~^\ell{}X~\mathsf{\mathbf{then}}~S_1~\mathsf{\mathbf{else}}~S_2~\mathsf{\mathbf{fi}}}R
	 \defined \begin{cases} \ddeps{S_1}R & \peek{X} \\
	  \ddeps{S_2}R & \neg \peek{X} \end{cases} \\ 
	  &\mbox{\note{we peek at the actual value of $X$ to choose the execution path}} \\
%
&\ddeps{\mathsf{\mathbf{while}}~^\ell{}X~\mathsf{\mathbf{do}}~S~\mathsf{\mathbf{od}}}R
\defined \begin{cases} \ddeps{\mathsf{\mathbf{while}}~^\ell{}X~\mathsf{\mathbf{do}}~S~\mathsf{\mathbf{od}}} \circ \ddeps{S}R & \peek{X} \\
	  \ddeps{S}R & \neg \peek{X} \end{cases} \\ 
%
&\ddeps{S_1; S_2}R \defined \ddeps{S_2} \circ 
\ddeps{S_1}R
	\end{align*}

\end{document}