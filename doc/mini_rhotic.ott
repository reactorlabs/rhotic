% NOTE: Some of the typesetting refers to macros defined in notes.tex
% This is fine, as long as the generated definitions are only used with notes.tex

metavar x       ::= {{ com metavariables }} {{ tex \mathit{[[x]]} }}

metavar l       ::= {{ com labels }} {{ lex numeral }} {{ tex \mathit{[[l]]} }}

metavar num     ::= {{ com numbers }} {{ lex numeral  }}
metavar chr     ::= {{ com character sequences }} {{ lex alphanum }}

metavar a       ::= {{ com address }} {{ tex \mathit{[[a]]} }}

indexvar n      ::= {{ com index variables }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

%%% CONCRETE GRAMMAR %%%

%%% Values %%%
bool {{ tex \mathsf{true} ~|~ \mathsf{false} ~|~ \bna }} :: 'bool_' ::=
                                    {{ com boolean literals }}
    | true          :: :: True          {{ tex \mathsf{true} }}
    | false         :: :: False         {{ tex \mathsf{false} }}
    | NA_b          :: :: NA            {{ com boolean \na }} {{ tex \bna }}

int {{ tex \cdots ~|~ -1 ~|~ 0 ~|~ 1 ~|~ \cdots ~|~ \ina }} :: 'int_' ::=
                                    {{ com integer literals }}
    | num           :: :: Int
    | ~ num         :: :: NegInt        {{ tex - [[num]] }}
    | NA_i          :: :: NA            {{ com integer \na }} {{ tex \ina }}

str {{ tex \cdots ~|~ \sna }} :: 'str_' ::=
                                    {{ com string literals }}
    | " chr "       :: :: Str           {{ tex ``[[chr]]" }}
    | NA_s          :: :: NA            {{ com string \na }} {{ tex \sna }}

v :: 'v_' ::=                       {{ com values $\vals$ }}
    | bool          :: :: Bool          {{ com \bvals }}
    | int           :: :: Int           {{ com \ivals }}
    | str           :: :: Str           {{ com \svals }}

%%% Simple expressions %%%
se :: 'se_' ::=                     {{ com simple expressions }}
    | v             :: :: Val           {{ com $[[v]] \in \vals$ }}
    | x             :: :: Var           {{ com $[[x]] \in \vars $ }}

%%% Unary operators %%%
uop :: 'uop_' ::=                   {{ com unary operators }} {{ tex \circ }}
    | !             :: :: Negate        {{ com logical negation }}
    | +             :: :: Plus
    | -             :: :: Minus

%%% Binary operators %%%a
bop :: 'bop_' ::=                   {{ com binary operators }} {{ tex \diamond }}
    | +             :: :: Plus
    | -             :: :: Minus
    | *             :: :: Times
    | /             :: :: Divide
    | %             :: :: Modulo        {{ com modulo }}
    | <             :: :: Less
    | <=            :: :: LessEqual
    | >=            :: :: GreaterEqual
    | >             :: :: Greater
    | =             :: :: Equal
    | =/=           :: :: NotEqual
    | /\            :: :: And           {{ com logical and }}
    | \/            :: :: Or            {{ com logical or }}

%%% Expressions %%%
e :: 'e_' ::=                           {{ com expressions }}
    | isNA se           :: :: IsNA          {{ tex [[isNA]]([[se]]) }}
    | uop se            :: :: UOp
        {{ com $[[uop]] \in \{ \neg, +, - \}$ }}
        {{ tex [[uop]][[se]] }}
    | se1 bop se2       :: :: BOp
        {{ com $[[bop]] \in \{ +, -, \times, \div, \%, <, \leq, =, \neq, >, \geq, \lor, \land \}$ }}
        {{ tex [[se1]] [[bop]] [[se2]] }}
    | se                :: :: SimpleExp

%%% Statements %%%
s :: 's_' ::=                                       {{ com statements }}
    | x <- e                        :: :: Assign
        {{ com $x \in \vars$ }}
    | x <- l ^ input()              :: :: Input
        {{ com $[[l]] \in \labels$ }}
        {{ tex [[x]] [[<-]]\, ^{[[l]]} [[input()]] }}
    | if se then s1 else s2 fi      :: :: If
        {{ tex [[if]]~[[se]]~[[then]]~[[s1]]~[[else]]~[[s2]]~[[fi]] }}
    | for x in se1 : se2 do s od    :: :: For
        {{ tex [[for]]~[[x]]~[[in]]~[[se1]]\negmedspace:\negmedspace[[se2]]~[[do]]~[[s]]~[[od]] }}
    | s1 ; s2                       :: :: Seq
    | e                             :: :: Exp

%%% Program %%%
P :: 'P_' ::=                                       {{ com program }}
    | s                             :: :: Statement

%%% Recorded simple expressions %%%
rse {{ tex \overline{se} }} :: 'rse_' ::=           {{ com recorded simple expressions }}
    | ( se , v )        :: :: SE

%%% Recorded expressions %%%
re {{ tex \overline{e} }} :: 're_' ::=              {{ com recorded expressions }}
    | ( isNA rse , v )          :: :: IsNA              {{ tex ([[isNA]]([[rse]]), [[v]]) }}
    | ( uop rse , v )           :: :: UOp
        {{ com $[[uop]] \in \{ \neg, +, - \}$ }}
        {{ tex ([[uop]][[rse]], [[v]]) }}
    | ( rse1 bop rse2 , v )     :: :: BOp
        {{ com $[[bop]] \in \{ +, -, \times, \div, \%, <, \leq, =, \neq, >, \geq, \lor, \land \}$ }}
        {{ tex ([[rse1]] [[bop]] [[rse2]], [[v]]) }}
    | ( rse , v )               :: :: SimpleExp

%%% Recorded statements %%%
rs {{ tex \overline{s} }} :: 'rs_' ::=              {{ com recorded statements }}
    | x <- re                       :: :: Assign
        {{ com $x \in \vars$ }}
        {{ tex [[x]] [[<-]] [[re]] }}
    | x <- ( l ^ input() , v )      :: :: Input
        {{ com $[[l]] \in \labels$ }}
        {{ tex [[x]] [[<-]]\, ( ^{[[l]]} [[input()]], [[v]] ) }}
    | if rse then . else . fi       :: :: If
        {{ tex [[if]]~[[rse]]~[[then]] \bullet [[else]] \bullet [[fi]] }}
        {{ com $\bullet$ is not recorded in this statement }}
    | for x in rse1 : rse2 do . od  :: :: For
        {{ tex [[for]]~[[x]]~[[in]]~[[rse1]]\negmedspace:\negmedspace[[rse2]]~[[do]] \bullet [[od]] }}
        {{ com $\bullet$ is not recorded in this statement }}
    | re                            :: :: Exp

%%% Environment %%%
E :: 'Env_' ::=                                     {{ com environment }}
    | empty                         :: :: Empty         {{ com empty environment }}
    | E [ x -> v ]                  :: :: UpdateEnv     {{ com environment update }}

%%% Input stream %%%
I :: 'I_' ::=                                       {{ com input stream }}
    | empty                         :: :: Empty         {{ com empty stream }}
    | v . I                         :: :: Single        {{ tex [[v]] \cdot [[I]] }}

%%% Machine configuration %%%
C :: 'C_' ::=                                       {{ com machine configuration }}
    | stop                          :: :: Stop          {{ tex \textsf{Stop} }}
    | s I E                         :: :: sIE           {{ tex [[s]]\enspace[[I]]\,[[E]] }}

%%% Label set %%%
L :: 'L_' ::=                                       {{ com label set }}
    | empty                         :: :: Empty         {{ com empty label set }}
    | { l1 , ... , ln }             :: :: Set           {{ com labels }}
    | L1 union L2                   :: :: Intersection  {{ com union }}

%%% Recorded state %%%
r :: 'r_' ::=                                       {{ com recorded state }}
    | [ rs E ]                      :: :: RecordedState
        {{ com recorded statement and environment }}
        {{ tex \langle [[rs]], [[E]] \rangle }}

%%% Execution trace %%%
T :: 'T_' ::=                                       {{ com execution trace }}
    | empty                         :: :: Empty         {{ com empty trace }}
    | r                             :: :: Single        {{ com singleton }} {{ tex [[r]] }}
    | T . r                         :: :: Append        {{ com append }} {{ tex [[T]] \cdot [[r]] }}
    | r . T                         :: :: Prepend       {{ com prepend }} {{ tex [[r]] \cdot [[T]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ANALYSIS GRAMMAR %%%
Lat :: 'Lat_' ::=                                   {{ com lattice }}
    | alpha ( v )                   :: :: alpha         {{ com abstraction of concrete value }} {{ tex \alpha([[v]]) }}
    | Auop Lat                      :: :: Auop          {{ com abstract unary operation }}
    | Lat1 Abop Lat2                :: :: Abop          {{ com abstract binary operation }}
    | NA_Lat                        :: :: NA            {{ com \na analysis }}

Av {{ tex \widehat{v} }} :: 'Av_' ::=               {{ com abstract value }}
    | NA_Av                         :: :: NA            {{ com \na analysis }}

AE {{ tex \widehat{E} }} :: 'AE_' ::=               {{ com abstract environment }}
    | NA_AE                         :: :: NA            {{ com \na analysis }}

AH {{ tex \widehat{H} }} :: 'AH_' ::=               {{ com abstract store }}
    | NA_AH                         :: :: NA            {{ com \na analysis }}

AC {{ tex \widehat{C} }} :: 'AC_' ::=               {{ com abstract configuration }}
    | NA_AC                         :: :: NA            {{ com \na analysis }}

M :: 'M_' ::=                                       {{ com analysis state }}
    | empty                         :: :: Empty         {{ com empty state }}
    | M [ l -> Lat ]                :: :: StateBind     {{ com \na state }}

%%% NA Analysis %%%

NA_Lat :: 'NA_Lat_' ::=                             {{ com \na analysis lattice }}
    | Top                           :: :: Top
    | NA                            :: :: NA            {{ tex \textsc{na} }}
    | ! NA                          :: :: NotNA         {{ tex \neg \textsc{na} }}
    | Bot                           :: :: Bot

NA_Av :: 'NA_Av_' ::=                               {{ com \na analysis abstract value }}
    | [ Lat1 , Lat2 , L ]           :: :: AVal          {{ tex \langle [[Lat1]] , [[Lat2]] , [[L]] \rangle }}

NA_AE :: 'NA_AE_' ::=                               {{ com \na analysis abstract environment }}
    | empty                         :: :: Empty         {{ com empty environment }}
    | AE [ x -> a ]                 :: :: EnvBind       {{ com environment binding }}

NA_AH :: 'NA_AH_' ::=                               {{ com \na analysis abstract store }}
    | empty                         :: :: Empty         {{ com empty heap }}
    | AH [ a -> Av ]                :: :: HeapBind      {{ com heap binding }}

NA_AC :: 'NA_AC_' ::=                               {{ com \na analysis state }}
    | AE AH M                       :: :: EM            {{ tex [[AE]]\,[[AH]]\,[[M]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TERMINALS %%%
terminals :: 'terminals_' ::=
    | isNA          :: :: IsNA      {{ tex \isna }}
    | input()       :: :: Input     {{ tex \ipt }}
    | <-            :: :: Assign    {{ tex \leftarrow }}
    | if            :: :: If        {{ tex \mathsf{if} }}
    | then          :: :: Then      {{ tex \mathsf{then} }}
    | else          :: :: Else      {{ tex \mathsf{else} }}
    | fi            :: :: Fi        {{ tex \mathsf{fi} }}
    | for           :: :: For       {{ tex \mathsf{for} }}
    | in            :: :: In        {{ tex \mathsf{in} }}
    | do            :: :: Do        {{ tex \mathsf{do} }}
    | od            :: :: Od        {{ tex \mathsf{od} }}
    | empty         :: :: Empty     {{ tex \emptyset }}
    | ->            :: :: MapsTo    {{ tex \mapsto }}
    | -se->         :: :: EvalSE    {{ tex \rightharpoonup }}
    | -e->          :: :: EvalE     {{ tex \longrightarrow }}
    | -->           :: :: EvalS     {{ tex \longmapsto }}
    | -rec-se->     :: :: RecSE     {{ tex \overset{\mathrm{rec} }{\rightharpoonup} }}
    | -rec-e->      :: :: RecE      {{ tex \overset{\mathrm{rec} }{\longrightarrow} }}
    | -rec->        :: :: RecS      {{ tex \overset{\mathrm{rec} }{\longmapsto} }}
    | !             :: :: Negate    {{ tex \neg }}
    | *             :: :: Times     {{ tex \times }}
    | /             :: :: Divide    {{ tex \div }}
    | <=            :: :: LEq       {{ tex \leq }}
    | >=            :: :: GEq       {{ tex \geq }}
    | =/=           :: :: NEq       {{ tex \neq }}
    | /\            :: :: And       {{ tex \land }}
    | \/            :: :: Or        {{ tex \lor }}
    | Top           :: :: Top       {{ tex \top }}
    | Bot           :: :: Bot       {{ tex \bot }}
    | -na-se->      :: :: NA_SEEval {{ tex \rightsquigarrow_{se} }}
    | -na-e->       :: :: NA_EEval  {{ tex \rightsquigarrow_{e} }}
    | -na-s->       :: :: NA_Eval   {{ tex \rightsquigarrow }}
    | union         :: :: Union     {{ tex \cup }}
    | Auop          :: :: Auop      {{ tex \widehat{\circ} }}
    | Abop          :: :: Abop      {{ tex \widehat{\diamond} }}

%%% FORMULAS %%%
formula :: 'formula_' ::=
  | judgement                               :: :: judgement
  | formula1 /\ formula2                    :: :: and
  | formula1 \/ formula2                    :: :: or
  | v = E ( x )                             :: :: lookup
  | v = [[ uop ]] ( se )                    :: :: primop_uop    {{ tex [[v]] = \llbracket [[uop]] \rrbracket_1 ([[se]]) }}
  | v = [[ bop ]] ( se1 , se2 )             :: :: primop_bop    {{ tex [[v]] = \llbracket [[bop]] \rrbracket_2 ([[se1]], [[se2]]) }}
  | v1 = v2                                 :: :: equal
  | v1 =/= v2                               :: :: not_equal
  | v1 < v2                                 :: :: less_than
  | v1 > v2                                 :: :: greater_than
  | v' = v1 + v2                            :: :: plus
  | v' = v1 - v2                            :: :: minus
  | E' = E [ x -> v ]                       :: :: env_update
  | I = v . I'                              :: :: input_stream  {{ tex [[I]] = [[v]] \cdot [[I']] }}
  | a = AE ( x )                            :: :: abstract_env_lookup
  | AE' = AE [ x -> a ]                     :: :: abstract_env_update
  | Av = AH ( a )                           :: :: abstract_heap_lookup
  | AH' = AH [ a -> Av ]                    :: :: abstract_heap_update
  | Av1 = Av2                               :: :: abstract_val_equal
  | fresh ( a )                             :: :: fresh_addr    {{ tex [[a]]~\text{fresh} }}
  | M [ l -> Lat ]                          :: :: update_state
  | M = forall-labs ( l : L ) . formula     :: :: forall_labs   {{ tex [[M]] = \forall [[l]] \in [[L]]\,.\,[[formula]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% CONCRETE OPERATIONAL SEMANTICS %%%
defns
operational_semantics :: '' ::=

    %%% Evaluation of simple expressions %%%
    defn
    E se -se-> v :: :: eval_se :: 'SE_'
        {{ com evaluation of simple expressions }}
        {{ tex [[E]]\enspace[[se]] [[-se->]] [[v]] }}
    by

        -----------  :: Literal
        E v -se-> v

        v = E(x)
        --------------  :: Variable
        E x -se-> v

    %%% Evaluation of expressions %%%
    defn
    E e -e-> v :: :: eval_e :: 'E_'
        {{ com evaluation of expressions }}
        {{ tex [[E]]\enspace[[e]] [[-e->]] [[v]] }}
    by

        E se -se-> v
        v = NA_b \/ v = NA_i \/ v = NA_s
        -------------------------------- :: IsNA
        E isNA se -e-> true

        E se -se-> v
        v =/= NA_b /\ v =/= NA_i /\ v =/= NA_s
        -------------------------------------- :: IsNotNA
        E isNA se -e-> false

        E se -se-> v
        v' = [[uop]](v)
        ----------------  :: UnaryOp
        E uop se -e-> v'

        E se1 -se-> v1
        E se2 -se-> v2
        v' = [[bop]](v1, v2)
        ---------------------  :: BinaryOp
        E se1 bop se2 -e-> v'

        E se -se-> v
        ------------  :: SimpleExpression
        E se -e-> v

    %%% Evaluation of statements %%%
    defn
    C --> C' :: :: eval_s :: 'S_'
        {{ com evaluation of program states }}
        {{ tex [[C]] [[-->]] [[C']] }}
    by

        E e -e-> v
        E' = E[x -> v]
        ---------------------  :: Assign
        x <- e I E --> v I E'

        I = v . I'
        E' = E[x -> v]
        --------------------------------  :: Input
        x <- l ^ input() I E --> v I' E'

        E se -se-> v
        v = true
        ---------------------------------------  :: IfTrue
        if se then s1 else s2 fi I E --> s1 I E

        E se -se-> v
        v = false
        ---------------------------------------  :: IfFalse
        if se then s1 else s2 fi I E --> s2 I E

        E se1 -se-> v1
        E se2 -se-> v2
        v1' = v1 + 1
        E' = E[x -> v1]
        v1 < v2
        ---------------------------------------------------------------------  :: ForIncr
        for x in se1 : se2 do s od I E --> s ; for x in v1' : v2 do s od I E'

        E se1 -se-> v1
        E se2 -se-> v2
        v1' = v1 - 1
        E' = E[x -> v1]
        v1 > v2
        ---------------------------------------------------------------------  :: ForDecr
        for x in se1 : se2 do s od I E --> s ; for x in v1' : v2 do s od I E'

        E se1 -se-> v1
        E se2 -se-> v2
        E' = E[x -> v1]
        v1 = v2
        -----------------------------------------  :: ForEnd
        for x in se1 : se2 do s od I E --> s I E'

        E e -e-> v
        ---------------  :: Expression
        e I E --> v I E

        s1 I E --> s1' I' E'
        ------------------------------  :: Seq1
        s1 ; s2 I E --> s1' ; s2 I' E'

        ---------------------  :: Seq2
        v ; s2 I E --> s2 I E

%%% RECORDING SEMANTICS %%%
defns
record :: '' ::=

    defn
    E se -rec-se-> rse :: :: rec_se :: 'RecSE_'
        {{ com recording a simple expression stores the result of that simple expression }}
        {{ tex [[E]]\enspace[[se]] [[-rec-se->]] [[rse]] }}
    by

        E se -se-> v
        ----------------------  :: SE
        E se -rec-se-> (se, v)

    defn
    E e -rec-e-> re :: :: rec_e :: 'RecE_'
        {{ com recording an expresion stores the result of that expression }}
        {{ tex [[E]]\enspace[[e]] [[-rec-e->]] [[re]] }}
    by

        E se -rec-se-> rse
        E isNA se -e-> v
        -------------------------------- :: IsNA
        E isNA se -rec-e-> (isNA rse, v)

        E se -rec-se-> rse
        E uop se -e-> v
        ------------------------------  :: UnaryOp
        E uop se -rec-e-> (uop rse, v)

        E se1 -rec-se-> rse1
        E se2 -rec-se-> rse2
        E se1 bop se2 -e-> v
        -----------------------------------------  :: BinaryOp
        E se1 bop se2 -rec-e-> (rse1 bop rse2, v)

        E se -rec-se-> rse
        E se -e-> v
        ----------------------  :: SimpleExpression
        E se -rec-e-> (rse, v)

    defn
    T , C -rec-> T' , C' :: :: rec_s :: 'RecS_'
        {{ com recording a program state updates the execution trace }}
        {{ tex [[T]],\:[[C]] [[-rec->]] [[T']],\:[[C']] }}
    by

        E e -rec-e-> re
        x <- e I E --> v I E'
        --------------------------------------------  :: Assign
        T, x <- e I E -rec-> T . [x <- re E], v I E'

        x <- l ^ input() I E --> v I' E'
        ---------------------------------------------------------------------  :: Input
        T, x <- l ^ input() I E -rec-> T . [x <- (l ^ input(), v) E], v I' E'

        E se -rec-se-> rse
        if se then s1 else s2 fi I E --> s I E
        -------------------------------------------------------------------------------  :: If
        T, if se then s1 else s2 fi I E -rec-> T . [if rse then . else . fi E], s I' E'

        E se1 -rec-se-> rse1
        E se2 -rec-se-> rse2
        for x in se1 : se2 do s od I E --> s' I E'
        --------------------------------------------------------------------------------------  :: For
        T, for x in se1 : se2 do s od I E -rec-> T . [for x in rse1 : rse2 do . od E], s' I E'

        E e -rec-e-> re
        e I E --> v I E
        ---------------------------------  :: Expression
        T, e I E -rec-> T . [re E], v I E

        empty, s1 I E -rec-> [rs1 E], s1' I' E'
        -----------------------------------------------------  :: Seq1
        T, s1 ; s2 I E -rec-> T . [rs1 E], s1' ; s2 I' E'

        --------------------------------------  :: Seq2
        T, v ; s2 I E -rec-> T . [((v, v), v) E], s2 I E

        -----------------------------------------  :: Stop
        T, v I E -rec-> T . [((v, v), v) E], stop


%%% NA ANALYSIS SEMANTICS %%%
%defns
%na_analysis :: 'NA_' ::=
%
%    defn
%    AE AH se -na-se-> a Av :: :: na_eval_se :: 'SE_'
%        {{ com abstract evaluation of simple expressions }}
%        {{ tex [[AE]]\,[[AH]]\enspace[[se]] [[-na-se->]] [[a]],[[Av]] }}
%    by
%
%        Av = [alpha(v), alpha(v), empty]
%        fresh(a)
%        --------------------------------  :: Literal
%        AE AH v -na-se-> a Av
%
%        a = AE(x)
%        Av = AH(a)
%        ---------------------  :: Variable
%        AE AH x -na-se-> a Av
%
%    defn
%    AE AH v e -na-e-> a Av :: :: na_eval_e :: 'E_'
%        {{ com abstract evaluation of expressions }}
%        {{ tex [[AE]]\,[[AH]]\,[[v]]\enspace[[e]] [[-na-e->]] [[a]],[[Av]] }}
%    by
%
%        Av = [!NA, !NA, empty]
%        fresh(a)
%        ----------------------------  :: IsNA
%        AE AH v isNA se -na-e-> a Av
%
%        AE AH se -na-se-> a [Lat1, Lat2, L]
%        Av = [alpha(v), Auop Lat2, L]
%        fresh(a')
%        -----------------------------------  :: UnaryOp
%        AE AH v uop se -na-e-> a' Av
%
%        AE AH se1 -na-se-> a1 [Lat11, Lat12, L1]
%        AE AH se2 -na-se-> a2 [Lat21, Lat22, L2]
%        Av = [alpha(v), Lat12 Abop Lat22, L1 union L2]
%        fresh(a)
%        ----------------------------------------------  :: BinaryOp
%        AE AH v se1 bop se2 -na-e-> a Av
%
%        AE AH se -na-se-> a Av
%        -----------------------  :: SimpleExpression
%        AE AH v se -na-e-> a Av
%
%    defn
%    T , AC -na-s-> T' , AC' :: :: na_analysis :: 'S_'
%        {{ com analysis of execution trace updates the abstract environment and analysis state }}
%        {{ tex [[T]],\:[[AC]] [[-na-s->]] [[T']],\:[[AC']] }}
%    by
%
%        AE AH v e -na-e-> a Av
%        fresh(a)
%        AE' = AE[x -> a]
%        AH' = AH[a -> Av]
%        ----------------------------------------------  :: Assign
%        [x <- e v E] . T, AE AH M -na-s-> T, AE' AH' M
%
%        Av = [alpha(v), Top, {l}]
%        fresh(a)
%        AE' = AE[x -> a]
%        AH' = AH[a -> Av]
%        --------------------------------------------------------  :: Input
%        [x <- l ^ input() v E] . T, AE AH M -na-s-> T, AE' AH' M
%
%        AE AH se -na-se-> a Av
%        Av = [Lat1, Lat2, L]
%        Av' = [Lat1, !NA, L]
%        AH' = AH[a -> Av']
%% TODO: this notation seems wrong
%        M' = forall-labs (l : L) . M[l -> !NA]
%        ----------------------------------------------------------------  :: If
%        [if se then s1 else s2 fi v E] . T, AE AH M -na-s-> T, AE AH' M'
%
%        AE AH se1 -na-se-> a1 Av1
%        AE AH se2 -na-se-> a2 Av2
%        Av1 = [Lat11, Lat12, L1]
%        Av2 = [Lat21, Lat22, L2]
%        Av1' = [Lat11, !NA, L1]
%        Av2' = [Lat21, !NA, L2]
%        AH' = AH[a1 -> Av1']
%        AH'' = AH'[a2 -> Av2']
%% TODO: this notation seems wrong
%        M' = forall-labs (l : L1 union L2) . M[l -> !NA]
%        ------------------------------------------------------------------  :: For
%        [for x in se1 : se2 do s od v E] . T, AE AH M -na-s-> T, AE AH' M'
%
%
%        [s1 v E] . T, AE AH M -na-s-> T, AE' AH' M'
%        -----------------------------------------------  :: Seq
%        [s1; s2 v E] . T, AE AH M -na-s-> T, AE' AH' M'
%
%        ---------------------------------------  :: Expression
%        [e v E] . T, AE AH M -na-s-> T, AE AH M
