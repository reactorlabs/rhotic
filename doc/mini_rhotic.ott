metavar x   ::= {{ com metavariables }} {{ tex \mathit{[[x]]} }}

metavar L   ::= {{ com labels }} {{ lex alphanum }} {{ tex \ell }}

metavar num ::= {{ com numbers }} {{ lex numeral  }}
metavar chr ::= {{ com character sequences }} {{ lex alphanum }}

indexvar n  ::= {{ com index variables }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

%%% Values %%%
bool {{ tex \mathsf{true} ~|~ \mathsf{false} ~|~ \bna }} :: 'bool_' ::=
                                    {{ com boolean literals }}
    | true          :: :: True          {{ tex \mathsf{true} }}
    | false         :: :: False         {{ tex \mathsf{false} }}
    | NA_b          :: :: NA            {{ com boolean \textsf{NA} }} {{ tex \mathsf{NA_B} }}

int {{ tex \cdots ~|~ -1 ~|~ 0 ~|~ 1 ~|~ \cdots ~|~ \ina }} :: 'int_' ::=
                                    {{ com integer literals }}
    | num           :: :: Int
    | ~ num         :: :: NegInt        {{ tex - [[num]] }}
    | NA_i          :: :: NA            {{ com integer \textsf{NA} }} {{ tex \mathsf{NA_I} }}

str {{ tex \cdots ~|~ \sna }} :: 'str_' ::=
                                    {{ com string literals }}
    | " chr "       :: :: Str           {{ tex ``[[chr]]" }}
    | NA_s          :: :: NA            {{ com string \textsf{NA} }} {{ tex \mathsf{NA_S} }}

v :: 'v_' ::=                       {{ com values }}
    | bool          :: :: Bool          {{ com \bvals }}
    | int           :: :: Int           {{ com \ivals }}
    | str           :: :: Str           {{ com \svals }}

%%% Simple expressions %%%
se :: 'se_' ::=                     {{ com simple expressions }}
    | v             :: :: Val           {{ com $v \in \vals$ }}
    | x             :: :: Var           {{ com $x \in \vars $ }}

%%% Unary operators %%%
uop :: 'uop_' ::=                   {{ com unary operators }} {{ tex \circ }}
    | !             :: :: Negate        {{ com logical negation }}
    | +             :: :: Plus
    | -             :: :: Minus

%%% Binary operators %%%a
bop :: 'bop_' ::=                   {{ com binary operators }} {{ tex \diamond }}
    | +             :: :: Plus
    | -             :: :: Minus
    | *             :: :: Times
    | /             :: :: Divide
    | %             :: :: Modulo        {{ com modulo }}
    | <             :: :: Less
    | <=            :: :: LessEqual
    | >=            :: :: GreaterEqual
    | >             :: :: Greater
    | =             :: :: Equal
    | =/=           :: :: NotEqual
    | /\            :: :: And           {{ com logical and }}
    | \/            :: :: Or            {{ com logical or }}

%%% Expressions %%%
e :: 'e_' ::=                           {{ com expressions }}
    | isNA se           :: :: IsNA          {{ tex [[isNA]]([[se]]) }}
    | uop se            :: :: UOp
        {{ com $[[uop]] \in \{ \neg, +, - \}$ }}
        {{ tex [[uop]][[se]] }}
    | se1 bop se2       :: :: BOp
        {{ com $[[bop]] \in \{ +, -, \times, \div, \%, <, \leq, =, \neq, >, \geq, \lor, \land \}$ }}
        {{ tex [[se1]] [[bop]] [[se2]] }}
    | se                :: :: SimpleExp

%%% Statements %%%
s :: 's_' ::=                                       {{ com statements }}
    | x <- e                        :: :: Assign
        {{ com $x \in \vars$ }}
    | x <- L ^ input()              :: :: Read
        {{ com $[[L]] \in \labels$ }}
        {{ tex [[x]] [[<-]]\, ^[[L]] [[input()]] }}
    | if se then s1 else s2 fi      :: :: If
        {{ tex [[if]]~[[se]]~[[then]]~[[s1]]~[[else]]~[[s2]]~[[fi]] }}
    | for x in se1 : se2 do s od    :: :: For
        {{ tex [[for]]~[[x]]~[[in]]~[[se1]]\negmedspace:\negmedspace[[se2]]~[[do]]~[[s]]~[[od]] }}
    | s1 ; s2                       :: :: Seq
    | e                             :: :: Exp

%%% Program %%%
P :: 'P_' ::=                                       {{ com program }}
    | s                             :: :: Statement

%%% Environment %%%
E :: 'Env_' ::=                                     {{ com environment }}
    | empty                         :: :: Empty         {{ com empty environment }}
    | E [ x -> v ]                  :: :: UpdateEnv     {{ com environment update }}

%%% Input stream %%%
I :: 'I_' ::=                                       {{ com input stream }}
    | empty                         :: :: Empty         {{ com empty stream }}
    | v . I                         :: :: Single        {{ tex [[v]] \cdot [[I]] }}

%%% Machine configuration %%%
C :: 'C_' ::=                                       {{ com machine configuration }}
    | s I E                         :: :: sIE           {{ tex \langle [[s]]\,[[I]]\,[[E]] \rangle }}

%%% TERMINALS %%%
terminals :: 'terminals_' ::=
    | isNA          :: :: IsNA      {{ tex \isna }}
    | input()       :: :: Input     {{ tex \mathsf{ {\color{teal}input}() } }}
    | <-            :: :: Assign    {{ tex \leftarrow }}
    | if            :: :: If        {{ tex \mathsf{if} }}
    | then          :: :: Then      {{ tex \mathsf{then} }}
    | else          :: :: Else      {{ tex \mathsf{else} }}
    | fi            :: :: Fi        {{ tex \mathsf{fi} }}
    | for           :: :: For       {{ tex \mathsf{for} }}
    | in            :: :: In        {{ tex \mathsf{in} }}
    | do            :: :: Do        {{ tex \mathsf{do} }}
    | od            :: :: Od        {{ tex \mathsf{od} }}
    | empty         :: :: Empty     {{ tex \emptyset }}
    | ->            :: :: MapsTo    {{ tex \mapsto }}
    | -se->         :: :: SEEval    {{ tex \rightharpoonup }}
    | -e->          :: :: EEval     {{ tex \longrightarrow }}
    | -->           :: :: SEval     {{ tex \longmapsto }}
    | !             :: :: Negate    {{ tex \neg }}
    | *             :: :: Times     {{ tex \times }}
    | /             :: :: Divide    {{ tex \div }}
    | <=            :: :: LEq       {{ tex \leq }}
    | >=            :: :: GEq       {{ tex \geq }}
    | =/=           :: :: NEq       {{ tex \neq }}
    | /\            :: :: And       {{ tex \land }}
    | \/            :: :: Or        {{ tex \lor }}

%%% FORMULAS %%%
formula :: 'formula_' ::=
  | judgement                       :: :: judgement
  | formula1 /\ formula2            :: :: and
  | formula1 \/ formula2            :: :: or
  | v = E ( x )                     :: :: lookup
  | v = [[ uop ]] ( se )            :: :: primop_uop    {{ tex [[v]] = \llbracket [[uop]] \rrbracket_1 ([[se]]) }}
  | v = [[ bop ]] ( se1 , se2 )     :: :: primop_bop    {{ tex [[v]] = \llbracket [[bop]] \rrbracket_2 ([[se1]], [[se2]]) }}
  | v1 = v2                         :: :: equal
  | v1 =/= v2                       :: :: not_equal
  | v1 < v2                         :: :: less_than
  | v1 > v2                         :: :: greater_than
  | v' = v1 + v2                    :: :: plus
  | v' = v1 - v2                    :: :: minus
  | E' = E [ x -> v ]               :: :: env_update
  | I = v . I'                      :: :: input_stream  {{ tex [[I]] = [[v]] \cdot [[I']] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
defns
operational_semantics :: '' ::=

    %%% Evaluation of simple expressions %%%
    defn
    E se -se-> v :: :: eval_se :: 'SE_'
        {{ com evaluation of simple expressions }}
        {{ tex [[E]]\enspace[[se]] [[-se->]] [[v]] }}
    by

        -----------  :: Literal
        E v -se-> v

        v = E(x)
        --------------  :: Lookup
        E x -se-> v

    %%% Evaluation of expressions %%%
    defn
    E e -e-> v :: :: eval_e :: 'E_'
        {{ com evaluation of expressions }}
        {{ tex [[E]]\enspace[[e]] [[-e->]] [[v]] }}
    by

        E se -se-> v
        v = NA_b \/ v = NA_i \/ v = NA_s
        -------------------------------- :: IsNA
        E isNA se -e-> true

        E se -se-> v
        v =/= NA_b /\ v =/= NA_i /\ v =/= NA_s
        -------------------------------------- :: IsNotNA
        E isNA se -e-> false

        E se -se-> v
        v' = [[uop]](se)
        ----------------  :: UnaryOp
        E uop se -e-> v'

        E se1 -se-> v1
        E se2 -se-> v2
        v' = [[bop]](v1, v2)
        ---------------------  :: BinaryOp
        E se1 bop se2 -e-> v'

        E se -se-> v
        ------------  :: SimpleExpression
        E se -e-> v

    %%% Evaluation of statements %%%
    defn
    s I E --> s' I' E' :: :: eval_s :: 'S_'
        {{ com evaluation of statements }}
        {{ tex [[s]]\enspace[[I]]\,[[E]] [[-->]] [[s']]\enspace[[I']]\,[[E']] }}
    by

        E e -e-> v
        E' = E[x -> v]
        ---------------------  :: Assign
        x <- e I E --> v I E'

        I = v . I'
        E' = E[x -> v]
        --------------------------------  :: Read
        x <- L ^ input() I E --> v I' E'

        E se -se-> v
        v = true
        ---------------------------------------  :: IfTrue
        if se then s1 else s2 fi I E --> s1 I E

        E se -se-> v
        v = false
        ---------------------------------------  :: IfFalse
        if se then s1 else s2 fi I E --> s2 I E

        E se1 -se-> v1
        E se2 -se-> v2
        v1' = v1 + 1
        E' = E[x -> v1]
        v1 < v2
        ---------------------------------------------------------------------  :: ForIncr
        for x in se1 : se2 do s od I E --> s ; for x in v1' : v2 do s od I E'

        E se1 -se-> v1
        E se2 -se-> v2
        v1' = v1 - 1
        E' = E[x -> v1]
        v1 > v2
        ---------------------------------------------------------------------  :: ForDecr
        for x in se1 : se2 do s od I E --> s ; for x in v1' : v2 do s od I E'

        E se1 -se-> v1
        E se2 -se-> v2
        E' = E[x -> v1]
        v1 = v2
        -----------------------------------------  :: ForEnd
        for x in se1 : se2 do s od I E --> s I E'

        s1 I E --> v I' E'
        ------------------------  :: Seq
        s1 ; s2 I E --> s2 I' E'

        E e -e-> v
        ---------------  :: Expression
        e I E --> e I E
